\documentclass[a4paper,oneside,14pt]{extreport}

\include{preamble}

\begin{document}
	\pagenumbering{Alph}
\include{title}
\pagenumbering{arabic}
\newpage
\tableofcontents
\lstset{
	language = python,
	basicstyle=\small\sffamily,
	numbers=left,
	numberstyle=\tiny,
	stepnumber=1,
	numbersep=5pt,
	xleftmargin =.19in,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	frame=single,
	tabsize=2,
	captionpos=t,
	breaklines=true,
	breakatwhitespace=false,
	escapeinside={\#*}{*)}
}

\newpage

\addcontentsline{toc}{chapter}{Введение}
\chapter*{Введение}
\textbf{Цель:} сравнить производительность последовательной и многопоточной версий алгоритма вычисления определителя матрицы.

\textbf{Задачи:}
\begin{enumerate}
	\item Изучить алгоритм вычисления определителя квадратной матрицы.
	\item Реализовать и протестировать:
	\begin{enumerate}
		\item последовательный алгоритм нахождения определителя матрицы;
		\item многопоточный алгоритм нахождения определителя матрицы.
	\end{enumerate}
	\item Провести сравнительный анализ алгоритмов по затрачиваемым ресурсам (процессорному времени работы).
	\item Определить, всегда ли при задании количества потоков, равному удвоенному количеству логических ядер процессора, достигается наибольшая эффективность.
\end{enumerate}
\newpage

\chapter{Аналитическая часть}
 Многопоточность — способность центрального процессора (CPU) или одного ядра
в многоядерном процессоре одновременновыполнять несколько процессов или
потоков, соответствующим образом поддерживаемых операционной системой.

Этот подход отличается от многопроцессорности, так как многопоточность
процессов и потоков совместно использует ресурсы одного или нескольких ядер:
вычислительных блоков, кэш-памяти ЦПУ или буфера перевода с преобразованием (TLB).

В тех случаях, когда многопроцессорные системы включают в себя несколько полных блоков обработки,
многопоточность направлена на максимизацию использования ресурсов одного ядра,
используя параллелизм на уровне потоков или на уровне инструкций.

Поскольку эти два метода являются взаимодополняющими,
их иногда объединяют в системах с несколькими многопоточными ЦП
и в ЦП с несколькими многопоточными ядрами.

Многопоточная парадигма стала более популярной с конца 1990-х годов,
поскольку усилия по дальнейшему использованию параллелизма на уровне инструкций застопорились.

Смысл многопоточности — квазимногозадачность на уровне одного исполняемого процесса.

Значит, все потоки процесса помимо общего адресного пространства имеют и общие дескрипторы файлов.
Выполняющийся процесс имеет как минимум один (главный) поток.

Многопоточность (как доктрину программирования) не следует путать ни с многозадачностью,
ни с многопроцессорностью, несмотря на то, что операционные системы,
реализующие многозадачность, как правило, реализуют и многопоточность.

Достоинства:
\begin{itemize}
	\item облегчение программы посредством использования общего адресного пространства;
	\item меньшие затраты на создание потока в сравнении с процессами;
	\item повышение производительности процесса за счёт распараллеливания процессорных вычислений;
	\item если поток часто теряет кэш, другие потоки могут продолжать
	использовать неиспользованные вычислительные ресурсы.
\end{itemize}

Недостатки:
\begin{itemize}
	\item несколько потоков могут вмешиваться друг в друга при совместном
	использовании аппаратных ресурсов \cite{Nemirovsky};
	\item с программной точки зрения аппаратная поддержка многопоточности
	более трудоемка для программного обеспечения \cite{Olukotun};
	\item проблема планирования потоков;
	\item специфика использования. Вручную настроенные программы на ассемблере,
	использующие расширения MMX или AltiVec и выполняющие предварительные выборки данных,
	не страдают от потерь кэша или неиспользуемых вычислительных ресурсов.
	Таким образом, такие программы не выигрывают от аппаратной многопоточности
	и действительно могут видеть ухудшенную производительность из-за конкуренции за общие ресурсы.
\end{itemize}
	Однако несмотря на количество недостатков, перечисленных выше,
	многопоточная парадигма имеет большой потенциал на сегодняшний день,
	и при должном написании кода позволяет значительно ускорить однопоточные алгоритмы.
	
	Определитель матрицы или просто определитель играет важную роль в решении систем линейных уравнений.
	Определитель матрицы $A$ обозначается как $\det A$, $\Delta A$, $|A|$
	
	Сформулировать определение определителя матрицы можно на основе его свойств.
	Определителем вещественной матрицы называется функция $\det{}: \mathbb{R}^{n\times n} \rightarrow \mathbb{R}$,
	обладающая следующими свойствами:
	
	\begin{enumerate}
		\item $\det{(A)}$ - кососимметрическая функция строк (столбцов) матрицы $A$
		\item $\det{(A)}$ - полилинейная функция строк(столбцов) матрицы $A$
		\item $\det{(A)} = 1$, где $E$ - единичная $n \times n$-матрица
	\end{enumerate}
	
\section{Нахождение определителя матрицы}
Ниже описаны способы нахождения определителя матрицы размеров $1 \times 1$, $2 \times 2$, $3 \times 23$, $n \times 1n$.

\subsection{Матрица $1 \times 1$}
Для матрицы первого порядка значение детерминанта равно единственному элементу этой матрицы:

\begin{equation}
\label{eq:det_1x1}
\delta  = |a_{11}| = a_{11}
\end{equation}

\subsection{Матрица $2 \times 2$}
Для матрицы $2 \times 2$ определитель вычисляется следующим образом:

\begin{equation}
\label{eq:det_2x2}
\Delta = \begin{vmatrix}
a & c \\
b & d
\end{vmatrix} = ad - bc
\end{equation}
Абсолютное значение определителя $|ad - bc|$ равно площади параллелограмма с вершинами
$(0, 0), (a, b), (a + c, b + d), (c, d)$.

\subsection{Матрица $3 \times 3$}
Определитель матрицы $3 \times 3$ можно вычислить по формуле:
\begin{equation}
\label{eq:det_3x3}
\begin{aligned}
\Delta = \begin{vmatrix}
a_{11} & a_{12} & a_{13} \\
a_{21} & a_{22} & a_{23} \\
a_{31} & a_{32} & a_{33}
\end{vmatrix} =
a_{11} \cdot \begin{vmatrix}
a_{22} & a_{23} \\
a_{32} & a_{33}
\end{vmatrix}
-
a_{12} \cdot \begin{vmatrix}
a_{21} & a_{23} \\
a_{31} & a_{33}
\end{vmatrix}
+
a_{13} \cdot \begin{vmatrix}
a_{21} & a_{22} \\
a_{31} & a_{32}
\end{vmatrix}
=
a_{11}a_{22}a_{33} - a_{11}a_{23}a_{32} - a_{12}a_{21}a_{33} +
a_{12}a_{23}a_{31} + a_{13}a_{21}a_{32} - a_{13}a_{22}a_{31}
\end{aligned}
\end{equation}

Определитель матрицы, составленной из векторов $a, b, c$ представляет
собой объём параллелепипеда, натянутого на вектора $a, b, c$.

\subsection{Матрица $n \times n$}
В общем случае, для матриц $n \times n$, где $n > 2$ определитель можно вычислить,
применив следующую рекурсивную формулу:

\begin{equation}
\label{eq:det_nxn}
\Delta =
\sum\limits_{j = 1}^{n} (-1)^{1 + j} \cdot a_{1j} \cdot M_{j}^{-1}
, \text{ где} M_{j}^{-1} - дополнительный минор к элементу a_{ij}
\end{equation}

В данной лабораторной работе стоит задача распараллеливания алгоритма нахождения определителя матрицы.
Так как каждое слагаемое для вычисления итогового определителя
вычисляется независимо от других и матрица не изменяется, для параллельного вычисления определителя
было решено распределять задачу вычисления слагаемых между потоками.

\section{Вывод}
Был рассмотрен алгоритм нахождения определителя квадратной матрицы размера $n \times n$, он независимо вычисляет слагаемые
для нахождения итогового определителя, что дает возможность для реализации параллельного варианта алгоритма.
\newpage

\chapter{Конструкторская часть}
Данный раздел содержит требования к разрабатываемому ПО, схемы реализуемых в работе алгоритмов (стандартного рекурсивного алгоритма вычисления определителя матриц и алгоритма с использованием потоков в виде схем потока-диспетчера и рабочего потока) и теоретический расчет повышения эффективности исполнения алгоритма по времени.

\section{Требования к программному обеспечению}
Требования, выдвигаемые к разрабатываемому ПО:
\begin{itemize}
	\item входные данные - размер матрицы (целое число), её элементы (вещественные числа);
	\item выходные данные - определитель матрицы (вещественное число).
\end{itemize}

\section{Схемы алгоритмов}
В данном пункте раздела представлены схемы реализуемых в работе алгоритмов.

На рисунке~\ref{img:count_det} представлена схема рекурсивного алгоритм нахождения определителя.
\begin{figure}[H]
	\centering
	\includegraphics[width=1.00\linewidth]{images/count_det}
	\caption{Схема рекурсивного алгоритма нахождения определителя}
	\label{img:count_det}
\end{figure}

На рисунке~\ref{img:thread_schema} представлена схема алгоритма подсчета слагаемых итогового определителя матрицы
при использовании потоков.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.85\linewidth]{images/thread_schema}
	\caption{Схема рекурсивного алгоритм нахождения определителя}
	\label{img:thread_schema}
\end{figure}

На рисунках~\ref{img:solver_1} -~\ref{img:solver_2} представлена схема алгоритма создания потоков,
разделения задач между ними и нахождения итогового определителя матрицы.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.85\linewidth]{images/solver_part_1}
	\caption{Схема рекурсивного алгоритм нахождения определителя}
	\label{img:solver_1}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.90\linewidth]{images/solver_part_2}
	\caption{Схема рекурсивного алгоритм нахождения определителя}
	\label{img:solver_2}
\end{figure}

\subsection{Теоретический расчет эффективности по времени}

При параллельном выполнении алгоритма изначальная матрица размером $n \times n$ делится на $n$ матриц
со значением $mult = (-1)^{j + 1} \cdot a_{1j}$,
где $j$ - номер элемента в первом ряду, для которого находится значение минора.
Далее "подматрицы" равномерно распределяются между потоками для вычисления значения миноров.
По мере работы потоки записывают результат в общий массив, и после окончания работы всех потоков
определитель исходной матрицы считается как сумма элементов в общем массиве.

При таком методе распараллеливания алгоритма для матрицы размером $n \times n$ эффективность
алгоритма по времени исполнения должна повышаться примерно в $k$ раз, где $k$ - количество потоков,
при $1 < k \leq n / 2$ или $k = n$.
Однако при $ n / 2 < k < n$ время исполнения алгоритма не увеличится более чем в $n / 2$ раза,
так как часть потоков будут искать два слагаемых итогового определителя, а часть - одно,
в таком случае произойдет простой второй части потоков.

\section{Вывод}
В данном разделе на основе приведенных в аналитическом разделе теоретических данных были составлены схемы алгоритмов для реализации в технологической части, в том числе, разделение вычисления определителя на потоки. 

Согласно проведенному теоретическому расчету эффективности по времени, эффективность версии алгоритма с потоками должна повышаться примерно в k раз, где k ($1 < k \leq n / 2$ или $k = n$) - количество потоков. Если k $ n / 2 < k < n$, время исполнения алгоритма не увеличится более чем в $n / 2$ раза.
\newpage

\chapter{Технологическая часть}
Данный раздел содержит обоснование выбора языка и среды разработки, реализацию алгоритмов.

\section{Средства реализации}
Для реализации программы был выбран язык программирования Python~\cite{python}. Такой выбор обусловлен следующими причинами:
\begin{itemize}
	\item имеется большой опыт разработки;
	\item имеет большое количество расширений и библиотек, в том числе библиотеку для работы с потоками, измерения времени, построения графиков;
	\item обладает информативной документацией;
\end{itemize}

\section{Реализация алгоритмов}
В листингах \ref{lst:det_rec} - \ref{lst:work_thread} представлены реализации рассматриваемых алгоритмов.
\newpage
\captionsetup{singlelinecheck=false, justification=raggedright}
\begin{lstlisting}[caption=Рекурсивный алгоритм вычисления определителя матрицы, label={lst:det_rec}]
def calculateDet(m: Matrix):
	s = 0
	if m.size == 2:
		s = (m.matrix[0][0] * m.matrix[1][1] - m.matrix[0][1] * m.matrix[1][0]) * m.mult
	else:
		for i in range(m.size):
			mul = m.matrix[0][i] * m.mult
			if i % 2 == 1:
				mul *= -1
			size = m.size - 1
			matrix = []
			for j in range(1, m.size):
				matrix.append([])
				for k in range(m.size):
					if k != i:
						matrix[-1].append(m.matrix[j][k])
			s += calculateDet(Matrix(size, mul, matrix))
	return s
\end{lstlisting}

\begin{lstlisting}[caption=Поток-диспетчер]
class Solver:
	def __init__(self, size: int = 0, matrix: Matrix = None):
		self.m = matrix
		if size == 0: 
			size = 9
		if self.m is None:
			self.m = Matrix(size).randomize()
		self.threadCount = 1
		self.threadManager = Manager()
		self.returnList = self.threadManager.list()
	
	def solve(self):
		activeThreads = []
		matrixPerThread = self.m.size / self.threadCount
		allMatrixes = []
		for i in range(self.m.size):
			mul = self.m.matrix[0][i] * self.m.mult
			if i % 2 == 1:
				mul *= -1
			size = self.m.size - 1
			matrix = []
			for j in range(1, self.m.size):
				matrix.append([])
				for k in range(self.m.size):
					if k != i:
						matrix[-1].append(self.m.matrix[j][k])
			allMatrixes.append(Matrix(size, mul, matrix))
		startIndex = 0
		threadTasksCount = []
		for i in range(self.threadCount):
			endIndex = round(matrixPerThread * (i + 1))
			if i == self.threadCount - 1:  # last thread
				threadMatrixes = allMatrixes[startIndex:]
			else:
				threadMatrixes = allMatrixes[startIndex:endIndex]
			startIndex = endIndex
			activeThreads.append(
			Process(target=calculateDetThreading, args=(threadMatrixes, self.returnList,)))
			threadTasksCount.append(len(threadMatrixes))
		for thread in activeThreads:
			thread.start()
		for thread in activeThreads:
			thread.join()
		result = sum(self.returnList)
		self.returnList = self.threadManager.list()
		return result
\end{lstlisting}
\newpage
\begin{lstlisting}[caption=Рабочий поток, label={lst:work_thread}]
def calculateDetThreading(matrixes, returnList: list):
	s = 0
	for m in matrixes:
		s += calculateDet(m)
	returnList.append(s)
\end{lstlisting}

\section{Тестирование}
В таблице \ref{tab:tests} представлены использованные для тестирования методом "черного ящика" данные, были рассмотрены все возможные тестовые случаи. Все тесты пройдены успешно.

\begin{table}[H]
	\begin{center}
		\captionsetup{justification=raggedleft, singlelinecheck=false}
		\caption[]{\label{tab:tests} Проведенные тесты}

	\begin{tabular}{|c|c|}
		\hline
		\rule[-1ex]{0pt}{2.5ex} Матрица & Определитель \\
		\hline
		\rule[-1ex]{0pt}{2.5ex} $\begin{pmatrix}
			0 & 0 \\
			0 & 0
		\end{pmatrix}$ & 0
		\\
		\hline
		\rule[-1ex]{0pt}{2.5ex} $\begin{pmatrix}
			1 & 0 & 0 \\
			0 & 1 & 0 \\
			0 & 0 & 1
		\end{pmatrix}$ & 1
		 \\
		\hline
		\rule[-1ex]{0pt}{2.5ex}	$\begin{pmatrix}
			1 & 2 & 3 \\
			4 & 5 & 6 \\
			7 & 8 & 12
		\end{pmatrix}$ & -9
		\\
		\hline
		\rule[-1ex]{0pt}{2.5ex} $\begin{pmatrix}
			1 & 2 & 3 & 4 \\
			5 & 6 & 7 & 8 \\
			9 & 10 & 11 & 12 \\
			13 & 14 & 15 & 16
		\end{pmatrix}$ & 0
		 \\
		 \hline
	\end{tabular}
\end{center}
\end{table}
\section{Выводы}
В данном разделе были реализованы и протестированы алгоритмы рекурсивного вычисления определителя и вычисления определителя с использованием многопоточности.
\newpage

\chapter{Экспериментальная часть}
В данном разделе сравниваются реализованные алгоритмы, дается сравнительная оценка затрат на время.

\section{Пример работы программы}
Пример работы программы представлен на рисунках \ref{fig:input_mat_ex} - \ref{fig:gener_ex}.
\captionsetup{singlelinecheck=true}
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{images/input_mat_ex}
	\caption{Пример работы программы для вводимой матрицы}
	\label{fig:input_mat_ex}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{images/generate_ex}
	\caption{Пример работы программы для вводимой матрицы}
	\label{fig:gener_ex}
\end{figure}


\section{Технические характеристики}
Технические характеристики устройства, на котором выполнялось исследование:
\begin{itemize}
	\item операционная система: Ubuntu 20.01 Linux x86\_64~\cite{ubuntu};
	\item оперативная память: 8 Гб;
	\item процессор: AMD Ryzen5 3500U~\cite{processor}:
	\begin{itemize}
		\item количество физических ядер: 4;
		\item количество логических ядер: 8.
	\end{itemize}
\end{itemize}

\section{Время выполнения алгоритмов}
Время выполнения алгоритмов измерялось на автоматически генерируемых квадратных матрицах необходимого размера (элементы которых - вещественные числа в диапазоне [-1000, 1000]) с использованием функции time библиотеки time. Усредненные результаты 10 замеров реального времени работы приведены в таблице ниже.

На рисунке \ref{fig:graph} представлена зависимость времени вычисления определителя матриц от размеров на основе таблицы \ref{tab:time}. Для матриц, размерность которых меньше 7, потоки работают дольше, чем классический рекурсивный алгоритм. Однако с увеличением размеров матрицы становится заметным преимущество использования параллельных вычислений. Таким образом, на матрицах, начиная с $8\vector8$, классический алгоритм работает в 1.5 раза дольше версии с использованием двух потоков
\begin{table}[H]
	\begin{center}
		\captionsetup{justification=raggedleft, singlelinecheck=false}
		\caption{\label{tab:time} Время вычисления определителя матриц разных размеров в миллисекундах}
		\begin{tabular}{|c c c c c c c|} 
			\hline
			Размер&1 поток&2 потока&4 потока&8 потоков&16 потоков&32 потока\\ [0.5ex]
			\hline
			4 &   10 &   14 &   17 &   23 &   38 &   67
			\\
			\hline
			5 &   10 &   14 &   17 &   23 &   38 &   68
			\\
			\hline
			6 &   12 &   15 &   17 &   24 &   39 &   68
			\\
			\hline
			7 &   22 &   19 &   21 &   25 &   40 &   72
			\\
			\hline
			8 &   75 &   47 &   37 &   42 &   57 &   82
			\\
			\hline
			9 &  529 &  306 &  304 &  164 &  155 &  182
			\\
			\hline
		\end{tabular}
	\end{center}
\end{table}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{images/graph}
	\caption{Зависимость времени работы алгоритмов от размера квадратной матрицы}
	\label{fig:graph}
\end{figure}

\section{Выводы}
По результатам проведенных замеров видно, что самым быстрым является алгоритм сортировки Шелла, причем его преимущество по сравнению с сортировкой выбором составил от 1.5 до 16 раз для произвольно упорядоченных массивов, от 2 до 56 раз для отсортированных массивов и от 2 до 22 раз для отсортированных в обратном порядке; по сравнению с сортировкой перемешиванием преимущество в среднем составило от 2 до 40 раз для различно упорядоченных массивов. Время работы алгоритмов шейкерной сортировки и сортировки выбором для лучшего случая - упорядоченного массива - практически совпало с незначительным преимуществом сортировки выбором. Наименее эффективным оказался алгоритм шейкерной сортировки, проигрыш которого по сравнению с сортировкой выбором составил 2-3 раза. Худшим случаем сортировки Шелла оказался произвольно упорядоченный массив, что говорит о неподходящем выбранном шаге сравнения элементов. 
\newpage

\addcontentsline{toc}{chapter}{Заключение}
\chapter*{Заключение}
В процессе выполнения лабораторной работы были изучены и реализованы алгоритмы сортировки перемешиванием, выбором и сортировки Шелла.

Согласно проведенному анализу трудоемкости алгоритмов в соответствии с выбранной моделью вычислений, приблизительная трудоемкость шейкерной сортировки для лучшего случая равна $3n^2$, худшего - $\frac{15}{2}n^2$; сортировки выбором для лучшего случая - $\frac{5}{2}n^2$, для худшего - $3n^2$. Согласно проанализированным источникам, трудоемкость сортировки Шелла для лучшего случая равна $n \log n$, для худшего случая - $n^2$. Лучший случай для выбранных алгоритмов оказался общим, это случай обработки отсортированного массива. Худший случай совпал для шейкерной сортировки и сортировки выбором, это обработка отсортированного в обратном порядке массива. Худшим случаем для алгоритма сортировки Шелла является случай неудачного выбора шага сравнения. Таким образом, наиболее эффективной является сортировка Шелла, наименее - шейкерная сортировка.

Было исследовано процессорное время выполнения выше обозначенных алгоритмов. В результате было выявлено, что самым быстрым является алгоритм сортировки Шелла, причем его выигрыш по сравнению с сортировкой выбором составил от 1.5 до 16 раз для произвольно упорядоченных массивов, от 2 до 56 раз для отсортированных массивов и от 2 до 24 раз для отсортированных в обратном порядке; по сравнению с сортировкой перемешиванием преимущество составило от 2 до 30 раз для произвольно упорядоченных, от 2 до 56 раз для упорядоченных и от 2 до 60 раз для упорядоченных в обратном порядке массивов. Преимущество по сравнению с обоими алгоритмами увеличивается с увеличением размера массива. Время работы алгоритмов шейкерной сортировки и сортировки выбором для лучшего случая - упорядоченного массива - практически совпало с незначительным преимуществом сортировки выбором. Наименее эффективным оказался алгоритм шейкерной сортировки, проигрыш которого по сравнению с сортировкой выбором составил 2-3 раза. Худшим случаем сортировки Шелла оказался произвольно упорядоченный массив, что говорит о неподходящем выбранном шаге сравнения элементов.

Таким образом, практика подтверждает теорию, и самым эффективным является алгоритм сортировки Шелла, наименее эффективным - шейкерной сортировки.

\newpage
\addcontentsline{toc}{chapter}{Список литературы}

\bibliographystyle{utf8gost705u}
\bibliography{bib_lab_3}
\nocite{*}


\end{document}